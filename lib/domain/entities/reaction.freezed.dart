// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'reaction.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Reaction {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReactionCopyWith<$Res> {
  factory $ReactionCopyWith(Reaction value, $Res Function(Reaction) then) =
      _$ReactionCopyWithImpl<$Res>;
}

/// @nodoc
class _$ReactionCopyWithImpl<$Res> implements $ReactionCopyWith<$Res> {
  _$ReactionCopyWithImpl(this._value, this._then);

  final Reaction _value;
  // ignore: unused_field
  final $Res Function(Reaction) _then;
}

/// @nodoc
abstract class _$$_ConfusedCopyWith<$Res> {
  factory _$$_ConfusedCopyWith(
          _$_Confused value, $Res Function(_$_Confused) then) =
      __$$_ConfusedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConfusedCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_ConfusedCopyWith<$Res> {
  __$$_ConfusedCopyWithImpl(
      _$_Confused _value, $Res Function(_$_Confused) _then)
      : super(_value, (v) => _then(v as _$_Confused));

  @override
  _$_Confused get _value => super._value as _$_Confused;
}

/// @nodoc

class _$_Confused extends _Confused {
  const _$_Confused() : super._();

  @override
  String toString() {
    return 'Reaction.confused()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Confused);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return confused();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return confused?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (confused != null) {
      return confused();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return confused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return confused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (confused != null) {
      return confused(this);
    }
    return orElse();
  }
}

abstract class _Confused extends Reaction {
  const factory _Confused() = _$_Confused;
  const _Confused._() : super._();
}

/// @nodoc
abstract class _$$_EyesCopyWith<$Res> {
  factory _$$_EyesCopyWith(_$_Eyes value, $Res Function(_$_Eyes) then) =
      __$$_EyesCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EyesCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_EyesCopyWith<$Res> {
  __$$_EyesCopyWithImpl(_$_Eyes _value, $Res Function(_$_Eyes) _then)
      : super(_value, (v) => _then(v as _$_Eyes));

  @override
  _$_Eyes get _value => super._value as _$_Eyes;
}

/// @nodoc

class _$_Eyes extends _Eyes {
  const _$_Eyes() : super._();

  @override
  String toString() {
    return 'Reaction.eyes()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Eyes);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return eyes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return eyes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (eyes != null) {
      return eyes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return eyes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return eyes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (eyes != null) {
      return eyes(this);
    }
    return orElse();
  }
}

abstract class _Eyes extends Reaction {
  const factory _Eyes() = _$_Eyes;
  const _Eyes._() : super._();
}

/// @nodoc
abstract class _$$_HeartCopyWith<$Res> {
  factory _$$_HeartCopyWith(_$_Heart value, $Res Function(_$_Heart) then) =
      __$$_HeartCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_HeartCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_HeartCopyWith<$Res> {
  __$$_HeartCopyWithImpl(_$_Heart _value, $Res Function(_$_Heart) _then)
      : super(_value, (v) => _then(v as _$_Heart));

  @override
  _$_Heart get _value => super._value as _$_Heart;
}

/// @nodoc

class _$_Heart extends _Heart {
  const _$_Heart() : super._();

  @override
  String toString() {
    return 'Reaction.heart()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Heart);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return heart();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return heart?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (heart != null) {
      return heart();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return heart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return heart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (heart != null) {
      return heart(this);
    }
    return orElse();
  }
}

abstract class _Heart extends Reaction {
  const factory _Heart() = _$_Heart;
  const _Heart._() : super._();
}

/// @nodoc
abstract class _$$_HoorayCopyWith<$Res> {
  factory _$$_HoorayCopyWith(_$_Hooray value, $Res Function(_$_Hooray) then) =
      __$$_HoorayCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_HoorayCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_HoorayCopyWith<$Res> {
  __$$_HoorayCopyWithImpl(_$_Hooray _value, $Res Function(_$_Hooray) _then)
      : super(_value, (v) => _then(v as _$_Hooray));

  @override
  _$_Hooray get _value => super._value as _$_Hooray;
}

/// @nodoc

class _$_Hooray extends _Hooray {
  const _$_Hooray() : super._();

  @override
  String toString() {
    return 'Reaction.hooray()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Hooray);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return hooray();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return hooray?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (hooray != null) {
      return hooray();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return hooray(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return hooray?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (hooray != null) {
      return hooray(this);
    }
    return orElse();
  }
}

abstract class _Hooray extends Reaction {
  const factory _Hooray() = _$_Hooray;
  const _Hooray._() : super._();
}

/// @nodoc
abstract class _$$_LaughCopyWith<$Res> {
  factory _$$_LaughCopyWith(_$_Laugh value, $Res Function(_$_Laugh) then) =
      __$$_LaughCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LaughCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_LaughCopyWith<$Res> {
  __$$_LaughCopyWithImpl(_$_Laugh _value, $Res Function(_$_Laugh) _then)
      : super(_value, (v) => _then(v as _$_Laugh));

  @override
  _$_Laugh get _value => super._value as _$_Laugh;
}

/// @nodoc

class _$_Laugh extends _Laugh {
  const _$_Laugh() : super._();

  @override
  String toString() {
    return 'Reaction.laugh()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Laugh);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return laugh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return laugh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (laugh != null) {
      return laugh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return laugh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return laugh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (laugh != null) {
      return laugh(this);
    }
    return orElse();
  }
}

abstract class _Laugh extends Reaction {
  const factory _Laugh() = _$_Laugh;
  const _Laugh._() : super._();
}

/// @nodoc
abstract class _$$_RocketCopyWith<$Res> {
  factory _$$_RocketCopyWith(_$_Rocket value, $Res Function(_$_Rocket) then) =
      __$$_RocketCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_RocketCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_RocketCopyWith<$Res> {
  __$$_RocketCopyWithImpl(_$_Rocket _value, $Res Function(_$_Rocket) _then)
      : super(_value, (v) => _then(v as _$_Rocket));

  @override
  _$_Rocket get _value => super._value as _$_Rocket;
}

/// @nodoc

class _$_Rocket extends _Rocket {
  const _$_Rocket() : super._();

  @override
  String toString() {
    return 'Reaction.rocket()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Rocket);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return rocket();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return rocket?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (rocket != null) {
      return rocket();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return rocket(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return rocket?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (rocket != null) {
      return rocket(this);
    }
    return orElse();
  }
}

abstract class _Rocket extends Reaction {
  const factory _Rocket() = _$_Rocket;
  const _Rocket._() : super._();
}

/// @nodoc
abstract class _$$_ThumbsDownCopyWith<$Res> {
  factory _$$_ThumbsDownCopyWith(
          _$_ThumbsDown value, $Res Function(_$_ThumbsDown) then) =
      __$$_ThumbsDownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ThumbsDownCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_ThumbsDownCopyWith<$Res> {
  __$$_ThumbsDownCopyWithImpl(
      _$_ThumbsDown _value, $Res Function(_$_ThumbsDown) _then)
      : super(_value, (v) => _then(v as _$_ThumbsDown));

  @override
  _$_ThumbsDown get _value => super._value as _$_ThumbsDown;
}

/// @nodoc

class _$_ThumbsDown extends _ThumbsDown {
  const _$_ThumbsDown() : super._();

  @override
  String toString() {
    return 'Reaction.thumbsDown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ThumbsDown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return thumbsDown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return thumbsDown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (thumbsDown != null) {
      return thumbsDown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return thumbsDown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return thumbsDown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (thumbsDown != null) {
      return thumbsDown(this);
    }
    return orElse();
  }
}

abstract class _ThumbsDown extends Reaction {
  const factory _ThumbsDown() = _$_ThumbsDown;
  const _ThumbsDown._() : super._();
}

/// @nodoc
abstract class _$$_ThumbsUpCopyWith<$Res> {
  factory _$$_ThumbsUpCopyWith(
          _$_ThumbsUp value, $Res Function(_$_ThumbsUp) then) =
      __$$_ThumbsUpCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ThumbsUpCopyWithImpl<$Res> extends _$ReactionCopyWithImpl<$Res>
    implements _$$_ThumbsUpCopyWith<$Res> {
  __$$_ThumbsUpCopyWithImpl(
      _$_ThumbsUp _value, $Res Function(_$_ThumbsUp) _then)
      : super(_value, (v) => _then(v as _$_ThumbsUp));

  @override
  _$_ThumbsUp get _value => super._value as _$_ThumbsUp;
}

/// @nodoc

class _$_ThumbsUp extends _ThumbsUp {
  const _$_ThumbsUp() : super._();

  @override
  String toString() {
    return 'Reaction.thumbsUp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ThumbsUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() confused,
    required TResult Function() eyes,
    required TResult Function() heart,
    required TResult Function() hooray,
    required TResult Function() laugh,
    required TResult Function() rocket,
    required TResult Function() thumbsDown,
    required TResult Function() thumbsUp,
  }) {
    return thumbsUp();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
  }) {
    return thumbsUp?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? confused,
    TResult Function()? eyes,
    TResult Function()? heart,
    TResult Function()? hooray,
    TResult Function()? laugh,
    TResult Function()? rocket,
    TResult Function()? thumbsDown,
    TResult Function()? thumbsUp,
    required TResult orElse(),
  }) {
    if (thumbsUp != null) {
      return thumbsUp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Confused value) confused,
    required TResult Function(_Eyes value) eyes,
    required TResult Function(_Heart value) heart,
    required TResult Function(_Hooray value) hooray,
    required TResult Function(_Laugh value) laugh,
    required TResult Function(_Rocket value) rocket,
    required TResult Function(_ThumbsDown value) thumbsDown,
    required TResult Function(_ThumbsUp value) thumbsUp,
  }) {
    return thumbsUp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
  }) {
    return thumbsUp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Confused value)? confused,
    TResult Function(_Eyes value)? eyes,
    TResult Function(_Heart value)? heart,
    TResult Function(_Hooray value)? hooray,
    TResult Function(_Laugh value)? laugh,
    TResult Function(_Rocket value)? rocket,
    TResult Function(_ThumbsDown value)? thumbsDown,
    TResult Function(_ThumbsUp value)? thumbsUp,
    required TResult orElse(),
  }) {
    if (thumbsUp != null) {
      return thumbsUp(this);
    }
    return orElse();
  }
}

abstract class _ThumbsUp extends Reaction {
  const factory _ThumbsUp() = _$_ThumbsUp;
  const _ThumbsUp._() : super._();
}
